1. 이벤트 캡쳐링과 이벤트 버블링

    버블링 : 중첩된 요소에 이벤트 핸들러가 동작하면, 요소를 감싸고 있는 부모요소의 핸드러도 동작한다.
            "이벤트가 상위 요소로 전파되는 단계"

        [기본 원리]
            const divHandler = () => {
                alert("div 태그");
            };
            const pHandler = () => {
                alert("p 태그");
            };

            return (
                <div onClick={divHandler}>
                    <p onClick={pHandler}>클릭</p>
                </div>
            )

            이 상황에서, "클릭"을 동작하면, 부모요소의 핸들러도 같이 동작한다.
            두 번의 alert 가 발생한다.

        [버블링 중지하기] -   e.stopPropagation();

            const divHandler = () => {
              alert("div 태그");
            };

            const pHandler = (e) => {
              e.stopPropagation();      //   e.stopPropagation();
              alert("p 태그");
            };

            return (
              <div>
                <div onClick={divHandler}>
                  <p onClick={pHandler}>클릭</p>
                </div>
            )

            e.stopPropagation() 을 통해, 중지 할 수 있다.
            "p 태그"의 aler 만 발생한다.
            

    캡처링 : 이벤트가, 하위 요소로 전파되는 흐름

        이벤트의 capture 옵션을 true 로 설정하면, 상위 이벤트를 눌렀을때, 하위 이벤트도 활성화 될 수 있다.

2. 호이스팅이란

    변수를 선언할때, 선언 부분이 최상단으로 끌어 올려지는 현상
    var로 변수를 선언시, 초기화 하는 과정이 동시에 발생하여, 호이스팅이 발생
    const/let 으로 변수를 선언시에, 초기화 과정이 동시에 일어나지 않아, 호이스팅이 발생하지 않음

    그러므로, var로 선언시, 실행 시점이 아니더라도, 참조가 가능하고, 참조하면 undefined 가 참조된다
    const/let 은, 실행 시점이 아니라면, 참조가 불가능하고, ReferenceError 가 발생한다.

3. 변수 선언의 3단계

    선언, 초기화, 할당

4. 실행 컨텍스트와 실행 순서

    "실행 컨텍스트"란 코드를 실행하는 환경을 생성, 실행 후 결과를 관리 하는 요소.

    전역 코드가 실행된다면
        1) "전역 실행 컨텍스트 생성"
        2) 실행 컨텍스트 스택 에 쌓인다.
        3) 전역 실행 컨텍스트 안에 "전역 실행 렉시컬 환경을 생성"
        4) 렉시컬 환경 안에는, 환경레코드(스코프, 변수, 함수 객체 등)을 생성 후, this 바인딩을 실시
        5) 외부 렉시컬 환경에 대한 참조 결정( 스코프 안에 있다면 참조 X, 스코프 안에, 없다면 "스코프체인"을 통해, 상위렉시컬 환경 참조)
        6) 전역 코드 실행

    해당 스코프의 "실체"는 컨텍스트가 아니라, "해당 스코프의 렉시컬 환경" 임을 명심
    렉시컬 환경에서, 참조하고, 생성하고, 바인딩한다.

5. 렉시컬 스코프
    함수를 "어디에서 호출"했냐 보다, "어디에서 선언 했느냐"가 스코프 결정에 영향을 주는 스코프 결정 방법

6. 렉시컬 환경
    렉시컬 스코프를 따를때, 각 지역 스코프에 해당하는 환경

    * 함수는 내부 슬롯에, "자기 자신이 정의된 환경(위치) 를 저장"한다. 그러므로, 렉시컬 환경을 따른다.

7. 클로저

    외부함수 안에, 중첩된 함수가 존재할때,
    중첩된 함수만 반횐되어, 외부함수보다 더 오래 생명을 유지할때, 그 중첩된 함수를 클로저 라고 부른다.

    [클로저의 생성 원리]
        외부함수의 컨텍스트는, 실행이 끝나면 반환되지 않아 제거되지만, 외부함수가 참조되고 있다면, 렉시컬 환경은 사라지지 않고 남아있다.
        중첩된 함수(클로저)는 "해당 외부함수의 렉시컬 환경을 참조하고 있기 때문에", 중첩함수인 클로저가 생성 되는 것입니다.

    [클로저의 사용 이유]
        안에 형성된 "내부함수에서만, 상태변경을 허용" 한다.
        이는, 외부에 의해, "상태가 의도치 않게 변형되는 것을 막고, 내부함수의 실행 로직을 은닉한다."

    [클로저의 코드]
        function outer(){
            const x = 10

            const inner = function(){
                console.log(x)
            }
            return inner  
        }

        const closerFunction = outer() 

        closerFunction()


        "중첩함수(내부) inner" 가 outer 안에 정의되어 있고,
        "내부함수 inner" 는 outer 안의 "변수를 참조"하고 있으며
        "내부함수 inner" 는 "외부함수에 의해 반환되었다."

        => 외부함수는 실행되었지만, "남은것은 내부 함수 뿐"(return 된 것은 내부함수 뿐이니까) 이다.
        "외부함수 보다 내부함수가 더 오래 살아남았기에", 중첩된 내부함수 inner 는 "클로저"이다.

8. this 의 용법

    this 는, 실행 단게에서 바인딩 되며,

    1) "일반 함수"에서의 this 는 window. 즉, "전역"을 가르킨다.

    2) "일반 객체"에서의 this 는 "객체 자기 자신"을 가르킨다.

    3) "생성자 함수"에서의 this 는, "자신이 생성할 인스턴스"를 가르킨다.

        function MyFunction(name) {
            this.name = name;
            this.sayHello = function () {
                console.log("Hello");
            };
        }
        
        const ms = new MyFunction("no");

        this 는 "자신이 생성할, 인스턴스"인 ms 를 가르킨다.


    4) "메서드" 에서의 this는 "호출한 객체 자신을 가르킨다."

            var value = 1;

            const obj = {
                value: 50,
                getValue() {
                    return this.value;
                },
            };
            
            console.log(obj.getValue());            // this 는 호출한 객체인 obj 에 바인딩
            
            const anotherobj = {
                value: 20,
            };
            
            anotherobj.getValue = obj.getValue;     // anotherobj에 getValue 를 할당
            
            console.log(anotherobj.getValue());     // this는 호출한 객체인 anotherobj 에 바인딩

    5) "콜백함수"에서의 this는, 일반함수 취급 하기 때문에, "window 즉, 글로벌을 가르킨다."
            
        
9. 비동기 함수란 무엇인가

    동기함수의 경우 현 코드의 실행완료와 동시에 다음 코드로 넘어갑니다.
    비동기 함수는, 현 코드의 실행 완료와는 무관하게, 다음 코드로 넘어갑니다.
    이는, 기다리는 시간 동안 다른 작업을 할 수 있으므로, 자원의 효율적인 사용에 기여햡니다.

10. Promise 란 무엇인가

    비동기 연산이 완료되었을때, 이후 처리할 함수나, 에러를 처리 하기 위해 사용하는 객체입니다.

    프로미스는 pending(대기), fulfilled(성공), reject(에러) 같은 처리를 지나 값 반환하고

    프로미스는 결과값, 또는 에러를 반환합니다.

    then 과 catch 를 통해, 결과를 도출합니다.

11. Async, await 와 Promise 의 차이점

    Promise 를 사용할때 가장 큰 문제점은, 연산이 많은 경우, 꼬리에 꼬리를 무는 then이 증식되어, 코드의 가독성이 떨어집니다.
    Async, await 는 Promise 의 결과값을 받아 올 수 있습니다.
    따라서, then 을 사용하지 않아, 코드의 가독성을 높일 수 있습니다.
    다만 에러 핸들링이 없기에, try, catch 를 사용하여, 에러 핸들링을 하게됩니다.

12. ESLint 란?
    자바스크립트의 언어와 소스코드를 분석하는 도구로, 
    코드의 스타일 규칙을 적용시켜, 에러를 찾고 패턴을 통일 시킬 수 있습니다.

    코드의 가독성을 높입니다.

13. ES(ECMAScript) 는 무엇인가

    ECMAScript 의 약자로, 자바스크립트의 표준, 규격을 나타내는 용어입니다.

14. ES6 문법에 추가된 것을 아는대로 설명

    1) let, const
    2) 템플릿 리터럴(백틱)
        : 중괄호를 사용한 "자바스크립트 표현식 사용가능", 줄 변경 가능

    3) 객체 리터럴
        메서드에 콜론과 function 을 사용하지 않아도 된다.
        함수명이 겹치면 한번만 쓸 수 있다.
        프로퍼티를 동적으로 생성할때, 객체 안에서 바로 사용 가능

    4) 화살표 함수

        함수 표현식을 화살표 함수로 표현 가능


    5) 구조 분해 할당

        객체나 배열에서, 값을 해체후 개별 변수에 담을 수 있는 기능

    6) Prmoise 

        비동기 함수를 의 결과값을 처리하는 Promise

    7) Class

        프로토타입 객체 지향 언어인 자바스크립트에, 클래스 기반 객체지향 프로그래밍도 가능하게 Class 도입

    8) String Method

        includes, startsWith, endsWith 등의 String 을 확인 할 수 있는 메서드 도입

    9) 디폴트 파라미터

        함수의 파라미터를 정할때, 기본값을 넣을 수 있음


    10) Spread 연산자

    11) import 와 export 

    등...

15. 웹팩과 바벨

    바벨은, 모든 실행환경에서 자바스크립트가 정상적으로 작동할 수 있도록 ES6 코드를 ES5 코드로 변환해주고,
            리액트의 JSX, TS 까지 변환해주는 자바스크립트 컴파일러 입니다.

    웹팩은, 프로젝트의 구조를 분석하고, 모듈을 비롯한 리소스를 찾은 후, 이를 브라우저에서 사용 할 수 있는 번들로 묶고 패킹하는, 모듈 번들러 입니다.
        모듈 번들러는, 여러개의 나눠져있는 파일을 "하나로 만들어주는 라이브러리"입니다.

    
16. JWT 방식에 대하여

    JWT 은 JSON 데이터로 이루어진 토큰을 말합니다.

    기존의 세션 인증 방식은, 인증관련 정보를 DB에 저장하고, 사용자가 인증이 되어있을 경우,
        인증상태를 계속 유지하는 상태성(Stateful) 의 특징을 가지고 있습니다.
        이 경우, 로그인 사용자가 늘어날 경우, 세션을 유지하는 메모리에 부하가 생길 수 있습니다.

    JWT 은 세션 인증 방식과 달리, 서버측에서 유저의 정보를 저장하고, 인증서를 발급하는 시스템입니다.
        기존의 세션 인증 방식의, 서버 자원낭비를 줄이고자, JWT 를 사용합니다.

        인증상태를 별도의 DB에 저장할 필요가 없어  서버에 과부하를 줄일 수 있습니다.
        토큰은 만든 서버만이 알 수 있고, 무상태성을 가지고 있어, 인증 상태를 저장할 추가적인 장치가 필요합니다.


17. Ajax 에 대하여

    자바스크립트를 이용한, 비동기식으로 XML을 이용하여 서버와 통신하는 방식입니다.
    JSON 데이터를 주로 다룹니다.
    브라우저가 가지고있는 XMLHttpRequest 객체를 이용해서 
        전체 페이지를 새로 고치지 않고도 페이지의 일부만을 위한 데이터를 로드할 수 있습니다.

    [장점]
        비동기식이므로, 자원의 효율적인 사용이 가능합니다.
        페이지 일부만을 업데이트 할 수 있으므로, 자원과 시간을 아낄 수 있습니다.

    [단점]
        연속적인 처리시, 서버 부하가 발생 할 수 있습니다.
        히스토리 관리가 되지 않습니다.
        에러가 명시 되지않아 디버깅에 용이하지 않습니다.
        CORS 에러를 처리할 추가적인 방식이 필요합니다.

18. use Strict 란?

    자바스크립트의 장점이자 단점은 코드의 유연성입니다.
    다만 오류를 발생시킬 확률이 높거나, 최적화 작업의 오류를 일으킬 수 있는 코드에 대해, 엄격모드를 적용할 수 있습니다.

    Strict 모드를 사용하게 되면,
    함수 내에 선언하지 않은 변수를 사용가능하게 하는 "암묵적 전역" 기능이 금지되고,
    delete 를 이용한 변수, 함수 등의 삭제 등, 여러가지 기능들이 금지됩니다.

    장점으로는 
    코드의 디버깅이 쉬워진다는 장점이 있습니다.

19. Prototype 이란

    자바스크립트에서 객체가 만들어지기 위해서는, 객체의 원형인 프로토타입을 이용하여, 새로운 객체를 만들어냅니다.
    프토토타입은, 객체를 확장하고 객체지향적인 프로그래밍을 할 수 있게 도와줍니다.

    이때, 만들어진 객체 안의 __proto__ 속성은, 자신을


20. Prototype Chaining