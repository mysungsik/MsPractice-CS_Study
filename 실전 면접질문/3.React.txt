1. Generator 함수의 사용

    function* 을 이용하여, 함수를 만들고, .next() 를 붙여 사용한다.
    yield 를 설정 하여, 한번 실행할때, 어디까지 실행 할지 결정한다.


    function* generatorFn() {       // * 을 붙이는 것을 잊지 말자.
        console.log("안녕");
        yield 1;
        console.log("명식");
        yield 2;
    }

    const generator = generatorFn();

    generator.next();               //  "안녕" 사용 할때마다 yield 로 나눠진 코드들이 사용된다.
    generator.next();               // "명식" 코드가 전부 끝나면, 더 실행되지 않는다.
    generator.next();               //  -- ( 아무것도 안찍힘)

    generatorFn().next()            // "안녕" => 직접 사용도 가능

2. React에서 State 란 무엇인가?

    웹 애플리케이션을 렌더하는데 있어, 영향을 미칠 수 있는 값 으로,
    state 는 컴포넌트 안에서 관리한다.

2. React 의 상태 관리 방법

    전역 상태 관리로, context API 나 Redux, MobX 등의 라이브러리를 사용하여 관리한다.

    Redux 의 경우, 
    Store 라는 "중앙 저장소" 안에서 State 를 관리합니다.
    Reducer에서는 State 변경을 위한 정의를 만들어 두고,
    View 에서 Action 을 Dispatch 하여, Reducer 를 실행시킬 수 있습니다.
    Reducer는 Action 이 호출되면, 실행되고, Store 안에 저장된 State 를 변경하며, 상태를 관리합니다.

        * 리듀서 안에는, 각 Action 의 타입에 해당하는 정의가 따로 정의되어있다.
        * Action 은, 리듀서 안에 있는 정의들 중, Action 의 타입과 같은 정의를 사용하게 만든다. 

    Context API 를 사용하여, 전역적인 데이터 공유로 상태 관리를 할 수도 있습니다.
    createContext 와, Provider 를 사용하여, "Context 의 값의 변화"를 구독하는 컴포넌트에 알릴 수 있습니다.
    
3. React와 Vue 의 차이

    [공통점]
        SPA 기반 프론트엔드 프레임워크/ 라이브러리 인 것

    [라이브러리와 프레임워크]
        리액트는 "라이브러리" 입니다.
            라이브러리는 참고가 용이하고, 일부만 가져와 사용 할 수 있다는 장점이 있습니다.
            또한 리액트는 UI 라이브러리 이기 때문에, 리액트 자체만으로, 전역 상태관리, 라우팅 등을 지원하지 않습니다.

            리액트는 자바스크립트 라이브러리 이기 때문에, 자바스크립트나 타입스크립트를 응용하여, 자유로운 개발이 가능합니다.

        뷰는 "프레임워크" 입니다.
            프레임워크가 지원해주는 형식과 문법에 따라 작성해야합니다.
            자유도가 떨어지지만 이는, 정해진 규칙과 문법에 존재하여, 통일된 코드 형식을 보유한다는 장점이 될 수 있습니다.

    [ 바인딩 ]

        리액트는 단방향 바인딩을 지원하여, UI 와 변수를 바인딩 할때, 한쪽으로만 가능합니다.
        뷰는 양방향 바인딩을 지원하여, 변경된 UI 가 바로 변수를 변경 시킬 수 있습니다.

    [코드 형태의 차이 ]
        리액트는 JSX(JavaScript XML) 형태로 코드를 작성하여 JavaScript 문법을 응용하기 때문에, JavaScript만으로 UI 로직과 DOM을 구현한다. 
        뷰는 HTML, JS, CSS 코드 영역을 분리해서 작성한다

    [ 컴포넌트의 분리와 재사용 ]

        리액트는 컴포넌트를 파일별로 분리 할 수 있으며, 재사용 하는 것이 용이하다.
        새로운 함수형 컴포넌트를 생산하고, props 형태로 전달하는 것이 용이하다

        뷰는, 새로운 컴포넌트를 만들어 분리하기 위해, 파일에 해당하는 template, script, style 을 모두 작성해야하며,
        props를 전달하는 과정에서도 해당 컴포넌트를 사용하는 모든 파일을 오가며 작성해주어야 한다.


4. React의 라이프 사이클

    컴포넌트의 라이프 사이클은, 페이지의 렌더링 준비부터, 페이지가 사라질때까지 지속됩니다.

    라이프사이클에는 크게, Mounting, Updating, UnMounting 의 단계로 구분되며

    리액트에서 주로 사용되는 함수형 컴포넌트의 경우에는

    Mounting 단계에서, 함수형 컴포넌트의 내부가 실행되고, State 를 정의하거나, 사용할 함수를 정의합니다. 
        (클래스 컴포넌트의 constructor 의 역할)
    또한, return 을 통해 화면에 렌더링합니다.

    화면에 무언가 바뀌면, Updating 단계가 실행됩니다. useState, useReducer 등의 훅들이 실행되고,
    화면을 업데이트합니다.

    공통적으로, 렌더 이후, useEffect 를 통해, 초기렌더(Mounting)시, 값 변경시(Updating) 수행 할 수 있는 함수를 사용할 수 있습니다.

    UnMounting 단계는 컴포넌트의 DOM 이 제거될때 수행됩니다. 종료시 useEffect 의 return 을 이용한 클린업 프로세스 를 사용하여, 
        종료시 함수를 동작 시킬 수 있습니다.


        * 바뀔때마다
            useEffect(()=>{})
        * 초기조건 
            useEffect(()=>{},[])
        * 값 변경
            useEffect(()=>{},[값])
        * 종료시
            useEffect(()=>{
                return ()=>{
                    "클린업 프로세스"
                }
            },[])

            import { useEffect } from "react";

            const UnMountCom = () => {
                useEffect(() => {
                    console.log("언마운트");
                    return () => {
                        console.log("클린업");      // 정말 UnMount 시, "클린업" 이 표시된다.
                    };
                }, []);
                return <div>언마운트</div>;
            };
            
            export default UnMountCom;
        


5. useMemo 와 useCallback 의 차이점

    [공통점]
        둘 모두 메모이제이션 훅으로 연산된 값을 자료구조에 저장후, 의존성을 만족할때에만 계산을 반복한다는 공통점이 있습니다.

    [useMemo]
        함수의 연산량이 많을때, 이전 결과값을 재사용 한다는 목적이 있다.
        연산 값이 같다면, 해당 "값을 저장"하고, 사용합니다.

    [useCallback]
        상속처럼 함수가 재생성되는 것을 방지하는 목적이 있다.
        값이 같다면, 함수를 재생성 하는 것이 아닌, 그 "함수를 다시 사용"하게 됩니다.

6. DOM 과 가상DOM

    DOM 은 Document Object Model 의 약자로
    HTML, XML 문서를 위한 구조화된 표현이다.

    DOM 은 문서를 표현, 저장, 조작하는 방법을 제공합니다
    웹 브라우저는 DOM 을 통해, DOM 의 내용을 해석하고, 웹 브라우저 화면에 나타내게한다.

    가상 DOM 은 DOM 문제점을 개선하기 위해 개발되었다.

    DOM 은 기존의 HTML과 CSS 를 파싱하여, 트리를 만든 후, 렌더 하는 작업에서,
    하나의 요소가 바뀌더라도 매번 전체를 리렌더 하는 동작을 가졌다.

    가상 DOM 은, 가상 돔 내에서 새로바뀐 UI를 리렌더링 하고,
    가상 DOM 안에서 비교 한 후 바뀐 부분만 추가, 삭제하여 DOM 으로 보낸다.
    전체가 아닌 부분적인 업데이트가 가능하게 만들어준다.

    불필요한 렌더링을 방지하여, 성능을 향상시킨다.


7. 클래스형과 함수형 컴포넌트의 차이

    클래스형 컴포넌트는, state 를 사용 가능하기에, 상태 저장이 가능하고, 리액트 라이프사이클 메서드를 사용할 수 있습니다.

    함수가 아닌 클래스이기에, render() 함수를 필수적으로 사용하여, JSX 를 반환합니다.

    함수형 컴포넌트는 클래스보다 선언하기 편하고, 한번 실행되면, 메모리상에서 사라지기에 메모리 자원을 사용합니다.
    함수형 컴포넌트는 Hook 을 사용할 수 있으며, retrun 문을 사용합니다.

8. props 와 State 

    props 와 state 모두, 리액트 컴포넌트에서 다루는 데이터로
    props 는 부모 컴포넌트에서 받아 온 데이터 입니다.
    state 는 컴포넌트 내부에서 선언되는 데이터 입니다.

            



5. Flux 구조란, Redux 와 Flux 의 관계