[디자인패턴] =========================================================================================

    : 객체간의 상호 관계를 정립하는 패턴

1. 싱글톤 패턴
    하나의 클래스의 하나의 인스턴스( 대표젹으로 데이터 베이스의 연결 클래스)

2. 팩토리 패턴
    상위 컴포넌트에서, 뼈대만을 결정 후
    상속받는 하위 컴포넌트에서, 세부내용을 정하는 패턴

3. 전략 패턴
    객체의 행위를 변경하고 싶을때, 미리 정의한 "캡슐화하 알고리즘"을 바꿔주어, 행위의 변경을 만들어주는 패턴

4. 옵저버 패턴
    객체의 상태변화를 관찰하다, 변화가 생길때, 옵저버들에게 변화를 알려주는 디자인 패턴

        예시) 블로그의 글을 포스트하면, 구독한 사람들에게 새 글을 보여준다.

    MVC 패턴의 경우, 주체인 Model 의 변경사항이 생겨, 옵저버로 알려주면, 이를 기반으로 Controller 가 작동하는 방식

    실용적인 예시로 정리하자면, "프록시(Proxy)"를 이용하여, 값을 "추적"하여, "옵저버들에게 전달", "동작" 하게 만들 수 있는 패턴이다.

        예시) input 에 ref 를 달아, 값이 변경되면, DOM 이 업데이트되는 것도, "프록시"를 이용한 "옵저버 패턴" 이다.

5. 이터레이터 패턴

    순환을 사용하는 패턴

6. 노출 모듈 패턴

    즉시실행 함수를 통해, public, private 같은 "접근 제어자" 를 만드는 패턴

        * 접근 제어자 : 값은 없지만, 값에 접근(읽거나 저장) 하는 프로퍼티 (ex. get, set ...)

7. MVC 패턴 **

    모델, 뷰, 컨트롤러로 구성된 디자인 패턴

    [장점]
        개발 프로세스에서 각 구성요소에 집중하여, 체계젹으로 개발이 가능하다는 장점
        재사용성과 확장성에 용이
        
    [단점]
        애플리케이션이 복잡해 질수록, 모델과 뷰의 관계가 복잡해진다.

        
    모델 : 애플리케이션의 "데이터베이스", "상수", "변수" 등의 데이터

    뷰 : 사용자의 인터페이스 요소

    컨트롤러 : 모델과 뷰를 잇는 "다리", "로직을 담당"한다. "여러개의 뷰와 여러개의 컨트롤러가 연결 가능하다."
                모델과 뷰의 "생명주기"를 다루며, 모델이나 뷰가 변경된다면, 각 구성요소에 그 내용을 알려준다.


        대표적인 MVC 패턴의 라이브러리 = REACT

        특징: "단방향 바인딩, 불변성(state를 setState 로만 변경가능)"

8.  MVP 패턴

    컨틀롤러가, "프레젠터" 로 교체된, MVC 의 파생 패턴

    하나의 프레젠터가 하나의 뷰가 일대일 관계를 지녀, 강한 결합을 지닌 디자인 패턴이다.

9. MVVM 패턴

    컨트롤러가, "View Model" 로 변경된, MVC 파생 패턴
    뷰 모델은, 화면 구성이 변할 때, 생명주기를 고려해 UI 데이터를 저장하고 관리하는 곳이다

        특징 : 뷰와 뷰모델(기존의 컨트롤러) 와 "양방향 바인딩"을 지원, "커맨드"를 가진다.

        대표적인 MVVM 패턴의 라이브러리 = VUE.js
    
    
[프로그래밍 패러다임] =========================================================================================
    : 프로그래밍의 개발 방법론

0. 분류

    프로그래밍 패러다임
        |
        |
        |------ 선언형
        |         |
        |         ---- 함수형
        |
        |
        |------ 명령형
                |
                |---- 객체 지향형
                |
                |---- 절차 지향형
        

1. 선언형 프로그래밍

    : "무엇을" 풀어내는가에 집중하는 패러다임

    하위 집합인, "함수형 프로그래밍" 이 존재한다.

2. 함수형 프로그래밍

    : 선언형의 하위 집합으로, "순수함수들을 하나씩 쌓아가며, 로직을 구현" 하고, "고차함수"를 통해, "재사용성을 높힌 패러다임"


        * 순수함수 : 함수에 들어가는 "매개변수에만" 영향을 받아 값을 내는 함수
                    매개변수 안에 같은 값을 넣으면 반드시 같은 값이 출력된다.

        * 고차함수 : 고차 함수는 함수를 인자로 받거나 또는 함수를 반환함으로써 작동 하는 함수를 말합니다. 
                    고차 함수는 "함수를 인자로 받거나" "함수를 출력(output)으로 반환하는(return) 함수"를 말합니다.

        대표적인 고차함수 = map()

            map() 은, "매개변수로 함수를 받아, 새 값을 도출"한다.

            Array.map(item=> (item.name) )


3. 객체 지향 프로그래밍

    : "객체들을 집합" 으로 프로그래밍의 상호작용을 표현하는 프로그래밍 방식

        작은 문제들을 해결하는 독립적인 객체(모듈)를 만들고, 조립하여, 큰 문제를 해결하는 형식을 띄는 방식이다. 
    
    특징으로는 "추상화", "캡슐화", "상속", "다형성" 이 있습니다.

    [장점]
        모듈화, 캡슐화로 인한, 유지보수 용이
        객체 자체가 하나의 프로세스를 처리하므로, 재사용에 용이

    [단점]
        코드 설계에 많은 시간이 소요된다.
        속도가 오래걸리고 메모리를 많이 사용한다.



4. 객체 지향 프로그래밍의 대원칙 "SOLID"

    1. S (SRP : Single Responsibility Principle) : 단일 책임 원칙
        모든 클래스는 "각각 하나의 책임만을 가져야한다."
        A 에 대한 클래스라면, A 에 관련된 수정과 A 에 관련된 로직만을 담아야한다.
        
    2. O (OCP: Open Closed Principle) : 개방-폐쇄 원칙
        유지 보수 사항이 생긴다면, "코드를 쉽게 확장 할 수 있고", 수정할 때에는 "닫혀있어야 한다"
        기존 코드 변경은 잘 되지 않지만, 확장의 경우 쉽게 되야 한다는 원칙

    3. L (LSP) 리스코프 치환 원칙

        상위 타입의 객체를 하위 타입의 객체로 치환해도 상위 타입을 사용하는 프로그램은 정상적으로 동작해야 한다. 는 원칙
        
    4. I (ISP, IneterFace Segregation Principle) : 인터페이스 분리 원칙

        하나의 통용되는 인터페이스보다, 구체적인 여러개의 인터페이스로 나누어야 한다는 원칙

    5. D (DIP, Dependency Inversion Principle) : 의존 역전 원칙

        의존 관계를 맺을 때 변화하기 쉬운 것 또는 자주 변화하는 것에 의존하기 보다는, 변화하기 어려운것, 거의 변화가 없는 것에 의존하라는 원칙입니다.


5. 절차형 프로그래밍

    순차적인 처리가 중요시 되는 프로그래밍 기법 

        돈을넣는다 -> 자판기에서 돈을 검사한다 -> 필요시 잔돈을 꺼내준다 -> 고객에게 제품을 건낸다

    등과 같은 "프로그램 전체가 유기적으로 연결되는 프로그래밍"

    [장점]
        처리속도가 빨라, 객체지향 프로그래밍보다 속도 면에서 유리하다.

    [단점]
        각 코드가 전부 연결되어 있어, 유지보수가 힘들다.

    대표 : C언어
        
